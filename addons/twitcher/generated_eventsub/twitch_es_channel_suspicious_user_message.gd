@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchESChannelSuspiciousUserMessage
	


## 
## #/components/schemas/ChannelSuspiciousUserMessageCondition
class Condition extends TwitchData:

	## The ID of a user that has permission to moderate the broadcaster’s channel and has granted your app permission to subscribe to this subscription type.
	@export var moderator_user_id: String:
		set(val): 
			moderator_user_id = val
			track_data(&"moderator_user_id", val)
	
	## User ID of the channel to receive chat message events for.
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	
	
	static func from_json(d: Dictionary) -> Condition:
		var result: Condition = Condition.new()
		if d.get("moderator_user_id", null) != null:
			result.moderator_user_id = d["moderator_user_id"]
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		return result
	


## 
## #/components/schemas/ChannelSuspiciousUserMessageEvent
class Event extends TwitchData:

	## The ID of the channel where the treatment for a suspicious user was updated.
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	## The display name of the channel where the treatment for a suspicious user was updated.
	@export var broadcaster_user_name: String:
		set(val): 
			broadcaster_user_name = val
			track_data(&"broadcaster_user_name", val)
	
	## The login of the channel where the treatment for a suspicious user was updated.
	@export var broadcaster_user_login: String:
		set(val): 
			broadcaster_user_login = val
			track_data(&"broadcaster_user_login", val)
	
	## The user ID of the user that sent the message.
	@export var user_id: String:
		set(val): 
			user_id = val
			track_data(&"user_id", val)
	
	## The user name of the user that sent the message.
	@export var user_name: String:
		set(val): 
			user_name = val
			track_data(&"user_name", val)
	
	## The user login of the user that sent the message.
	@export var user_login: String:
		set(val): 
			user_login = val
			track_data(&"user_login", val)
	
	## The status set for the suspicious user. Can be the following: “none”, “active_monitoring”, or “restricted”
	@export var low_trust_status: String:
		set(val): 
			low_trust_status = val
			track_data(&"low_trust_status", val)
	
	## A list of channel IDs where the suspicious user is also banned.
	@export var shared_ban_channel_ids: Array[String]:
		set(val): 
			shared_ban_channel_ids = val
			track_data(&"shared_ban_channel_ids", val)
	
	## User types (if any) that apply to the suspicious user, can be “manually_added”, “ban_evader”, or “banned_in_shared_channel”.
	@export var types: Array[String]:
		set(val): 
			types = val
			track_data(&"types", val)
	
	## A ban evasion likelihood value (if any) that as been applied to the user automatically by Twitch, can be “unknown”, “possible”, or “likely”.
	@export var ban_evasion_evaluation: String:
		set(val): 
			ban_evasion_evaluation = val
			track_data(&"ban_evasion_evaluation", val)
	
	## The structured chat message.
	@export var message: Message:
		set(val): 
			message = val
			track_data(&"message", val)
	
	
	
	static func from_json(d: Dictionary) -> Event:
		var result: Event = Event.new()
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		if d.get("broadcaster_user_name", null) != null:
			result.broadcaster_user_name = d["broadcaster_user_name"]
		if d.get("broadcaster_user_login", null) != null:
			result.broadcaster_user_login = d["broadcaster_user_login"]
		if d.get("user_id", null) != null:
			result.user_id = d["user_id"]
		if d.get("user_name", null) != null:
			result.user_name = d["user_name"]
		if d.get("user_login", null) != null:
			result.user_login = d["user_login"]
		if d.get("low_trust_status", null) != null:
			result.low_trust_status = d["low_trust_status"]
		if d.get("shared_ban_channel_ids", null) != null:
			for value in d["shared_ban_channel_ids"]:
				result.shared_ban_channel_ids.append(value)
		if d.get("types", null) != null:
			for value in d["types"]:
				result.types.append(value)
		if d.get("ban_evasion_evaluation", null) != null:
			result.ban_evasion_evaluation = d["ban_evasion_evaluation"]
		if d.get("message", null) != null:
			result.message = Message.from_json(d["message"])
		return result
	


## The structured chat message.
## #/components/schemas/ChannelSuspiciousUserMessageEvent/Message
class Message extends TwitchData:

	## The UUID that identifies the message.
	@export var message_id: String:
		set(val): 
			message_id = val
			track_data(&"message_id", val)
	
	## The chat message in plain text.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## Ordered list of chat message fragments.
	@export var fragments: Array[Fragments]:
		set(val): 
			fragments = val
			track_data(&"fragments", val)
	
	
	
	static func from_json(d: Dictionary) -> Message:
		var result: Message = Message.new()
		if d.get("message_id", null) != null:
			result.message_id = d["message_id"]
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("fragments", null) != null:
			for value in d["fragments"]:
				result.fragments.append(Fragments.from_json(value))
		return result
	


## Ordered list of chat message fragments.
## #/components/schemas/ChannelSuspiciousUserMessageEvent/Message/Fragments
class Fragments extends TwitchData:

	## The type of message fragment. Possible values: -text -cheermote -emote
	@export var type: String:
		set(val): 
			type = val
			track_data(&"type", val)
	
	## Message text in fragment.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## Optional. Metadata pertaining to the cheermote.
	@export var cheermote: Cheermote:
		set(val): 
			cheermote = val
			track_data(&"cheermote", val)
	
	## Optional. Metadata pertaining to the emote.
	@export var emote: Emote:
		set(val): 
			emote = val
			track_data(&"emote", val)
	
	
	
	static func from_json(d: Dictionary) -> Fragments:
		var result: Fragments = Fragments.new()
		if d.get("type", null) != null:
			result.type = d["type"]
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("cheermote", null) != null:
			result.cheermote = Cheermote.from_json(d["cheermote"])
		if d.get("emote", null) != null:
			result.emote = Emote.from_json(d["emote"])
		return result
	


## Optional. Metadata pertaining to the cheermote.
## #/components/schemas/ChannelSuspiciousUserMessageEvent/Message/Fragments/Cheermote
class Cheermote extends TwitchData:

	## The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is “Cheer” and you want to cheer 100 Bits, the full Cheermote string is Cheer100. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.
	@export var prefix: String:
		set(val): 
			prefix = val
			track_data(&"prefix", val)
	
	## The amount of Bits cheered.
	@export var bits: String:
		set(val): 
			bits = val
			track_data(&"bits", val)
	
	## The tier level of the cheermote.
	@export var tier: String:
		set(val): 
			tier = val
			track_data(&"tier", val)
	
	
	
	static func from_json(d: Dictionary) -> Cheermote:
		var result: Cheermote = Cheermote.new()
		if d.get("prefix", null) != null:
			result.prefix = d["prefix"]
		if d.get("bits", null) != null:
			result.bits = d["bits"]
		if d.get("tier", null) != null:
			result.tier = d["tier"]
		return result
	


## Optional. Metadata pertaining to the emote.
## #/components/schemas/ChannelSuspiciousUserMessageEvent/Message/Fragments/Emote
class Emote extends TwitchData:

	## An ID that uniquely identifies this emote.
	@export var id: String:
		set(val): 
			id = val
			track_data(&"id", val)
	
	## An ID that identifies the emote set that the emote belongs to.
	@export var emote_set_id: String:
		set(val): 
			emote_set_id = val
			track_data(&"emote_set_id", val)
	
	
	
	static func from_json(d: Dictionary) -> Emote:
		var result: Emote = Emote.new()
		if d.get("id", null) != null:
			result.id = d["id"]
		if d.get("emote_set_id", null) != null:
			result.emote_set_id = d["emote_set_id"]
		return result
	