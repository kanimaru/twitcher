@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchESChannelBitsUse
	


## 
## #/components/schemas/ChannelBitsUseCondition
class Condition extends TwitchData:

	## The user ID of the channel broadcaster. Maximum: 1.
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	
	
	static func from_json(d: Dictionary) -> Condition:
		var result: Condition = Condition.new()
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		return result
	


## 
## #/components/schemas/ChannelBitsUseEvent
class Event extends TwitchData:

	## The User ID of the channel where the Bits were redeemed.
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	## The login of the channel where the Bits were used.
	@export var broadcaster_user_login: String:
		set(val): 
			broadcaster_user_login = val
			track_data(&"broadcaster_user_login", val)
	
	## The display name of the channel where the Bits were used.
	@export var broadcaster_user_name: String:
		set(val): 
			broadcaster_user_name = val
			track_data(&"broadcaster_user_name", val)
	
	## The User ID of the redeeming user.
	@export var user_id: String:
		set(val): 
			user_id = val
			track_data(&"user_id", val)
	
	## The login name of the redeeming user.
	@export var user_login: String:
		set(val): 
			user_login = val
			track_data(&"user_login", val)
	
	## The display name of the redeeming user.
	@export var user_name: String:
		set(val): 
			user_name = val
			track_data(&"user_name", val)
	
	## The number of Bits used.
	@export var bits: int:
		set(val): 
			bits = val
			track_data(&"bits", val)
	
	## Possible values are: cheerpower_up
	@export var type: String:
		set(val): 
			type = val
			track_data(&"type", val)
	
	## Optional. An object that contains the user message and emote information needed to recreate the message.
	@export var message: Message:
		set(val): 
			message = val
			track_data(&"message", val)
	
	## Optional. Data about Power-up.
	@export var power_up: PowerUp:
		set(val): 
			power_up = val
			track_data(&"power_up", val)
	
	
	
	static func from_json(d: Dictionary) -> Event:
		var result: Event = Event.new()
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		if d.get("broadcaster_user_login", null) != null:
			result.broadcaster_user_login = d["broadcaster_user_login"]
		if d.get("broadcaster_user_name", null) != null:
			result.broadcaster_user_name = d["broadcaster_user_name"]
		if d.get("user_id", null) != null:
			result.user_id = d["user_id"]
		if d.get("user_login", null) != null:
			result.user_login = d["user_login"]
		if d.get("user_name", null) != null:
			result.user_name = d["user_name"]
		if d.get("bits", null) != null:
			result.bits = d["bits"]
		if d.get("type", null) != null:
			result.type = d["type"]
		if d.get("message", null) != null:
			result.message = Message.from_json(d["message"])
		if d.get("power_up", null) != null:
			result.power_up = PowerUp.from_json(d["power_up"])
		return result
	


## Optional. An object that contains the user message and emote information needed to recreate the message.
## #/components/schemas/ChannelBitsUseEvent/Message
class Message extends TwitchData:

	## The chat message in plain text.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## The ordered list of chat message fragments.
	@export var fragments: Array[Fragments]:
		set(val): 
			fragments = val
			track_data(&"fragments", val)
	
	
	
	static func from_json(d: Dictionary) -> Message:
		var result: Message = Message.new()
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("fragments", null) != null:
			for value in d["fragments"]:
				result.fragments.append(Fragments.from_json(value))
		return result
	


## The ordered list of chat message fragments.
## #/components/schemas/ChannelBitsUseEvent/Message/Fragments
class Fragments extends TwitchData:

	## The message text in fragment.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## The type of message fragment. Possible values are: textcheermoteemote
	@export var type: String:
		set(val): 
			type = val
			track_data(&"type", val)
	
	## Optional. The metadata pertaining to the emote.
	@export var emote: Emote:
		set(val): 
			emote = val
			track_data(&"emote", val)
	
	## Optional. The metadata pertaining to the cheermote.
	@export var cheermote: Cheermote:
		set(val): 
			cheermote = val
			track_data(&"cheermote", val)
	
	
	
	static func from_json(d: Dictionary) -> Fragments:
		var result: Fragments = Fragments.new()
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("type", null) != null:
			result.type = d["type"]
		if d.get("emote", null) != null:
			result.emote = Emote.from_json(d["emote"])
		if d.get("cheermote", null) != null:
			result.cheermote = Cheermote.from_json(d["cheermote"])
		return result
	


## Optional. The metadata pertaining to the emote.
## #/components/schemas/ChannelBitsUseEvent/Message/Fragments/Emote
class Emote extends TwitchData:

	## The ID that uniquely identifies this emote.
	@export var id: String:
		set(val): 
			id = val
			track_data(&"id", val)
	
	## The ID that identifies the emote set that the emote belongs to.
	@export var emote_set_id: String:
		set(val): 
			emote_set_id = val
			track_data(&"emote_set_id", val)
	
	## The ID of the broadcaster who owns the emote.
	@export var owner_id: String:
		set(val): 
			owner_id = val
			track_data(&"owner_id", val)
	
	## The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only static. But if the emote is available as a static PNG and an animated GIF, the array contains static and animated. The possible formats are: animated - An animated GIF is available for this emote.static - A static PNG file is available for this emote.
	@export var format: Array[String]:
		set(val): 
			format = val
			track_data(&"format", val)
	
	
	
	static func from_json(d: Dictionary) -> Emote:
		var result: Emote = Emote.new()
		if d.get("id", null) != null:
			result.id = d["id"]
		if d.get("emote_set_id", null) != null:
			result.emote_set_id = d["emote_set_id"]
		if d.get("owner_id", null) != null:
			result.owner_id = d["owner_id"]
		if d.get("format", null) != null:
			for value in d["format"]:
				result.format.append(value)
		return result
	


## Optional. The metadata pertaining to the cheermote.
## #/components/schemas/ChannelBitsUseEvent/Message/Fragments/Cheermote
class Cheermote extends TwitchData:

	## The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is “Cheer” and you want to cheer 100 Bits, the full Cheermote string is Cheer100. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.
	@export var prefix: String:
		set(val): 
			prefix = val
			track_data(&"prefix", val)
	
	## The amount of Bits cheered.
	@export var bits: int:
		set(val): 
			bits = val
			track_data(&"bits", val)
	
	## The tier level of the cheermote.
	@export var tier: int:
		set(val): 
			tier = val
			track_data(&"tier", val)
	
	
	
	static func from_json(d: Dictionary) -> Cheermote:
		var result: Cheermote = Cheermote.new()
		if d.get("prefix", null) != null:
			result.prefix = d["prefix"]
		if d.get("bits", null) != null:
			result.bits = d["bits"]
		if d.get("tier", null) != null:
			result.tier = d["tier"]
		return result
	


## Optional. Data about Power-up.
## #/components/schemas/ChannelBitsUseEvent/PowerUp
class PowerUp extends TwitchData:

	## Possible values: message_effectcelebrationgigantify_an_emote
	@export var type: String:
		set(val): 
			type = val
			track_data(&"type", val)
	
	## Optional. Emote associated with the reward.
	@export var emote: PowerUp_Emote:
		set(val): 
			emote = val
			track_data(&"emote", val)
	
	## Optional. The ID of the message effect.
	@export var message_effect_id: String:
		set(val): 
			message_effect_id = val
			track_data(&"message_effect_id", val)
	
	
	
	static func from_json(d: Dictionary) -> PowerUp:
		var result: PowerUp = PowerUp.new()
		if d.get("type", null) != null:
			result.type = d["type"]
		if d.get("emote", null) != null:
			result.emote = PowerUp_Emote.from_json(d["emote"])
		if d.get("message_effect_id", null) != null:
			result.message_effect_id = d["message_effect_id"]
		return result
	


## Optional. Emote associated with the reward.
## #/components/schemas/ChannelBitsUseEvent/PowerUp/Emote
class PowerUp_Emote extends TwitchData:

	## The ID that uniquely identifies this emote.
	@export var id: String:
		set(val): 
			id = val
			track_data(&"id", val)
	
	## The human readable emote token.
	@export var name: String:
		set(val): 
			name = val
			track_data(&"name", val)
	
	
	
	static func from_json(d: Dictionary) -> PowerUp_Emote:
		var result: PowerUp_Emote = PowerUp_Emote.new()
		if d.get("id", null) != null:
			result.id = d["id"]
		if d.get("name", null) != null:
			result.name = d["name"]
		return result
	