@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchESAutomodMessageHold
	


## 
## #/components/schemas/AutomodMessageHoldCondition
class Condition extends TwitchData:

	## User ID of the broadcaster (channel).
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	## User ID of the moderator.
	@export var moderator_user_id: String:
		set(val): 
			moderator_user_id = val
			track_data(&"moderator_user_id", val)
	
	
	
	static func from_json(d: Dictionary) -> Condition:
		var result: Condition = Condition.new()
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		if d.get("moderator_user_id", null) != null:
			result.moderator_user_id = d["moderator_user_id"]
		return result
	


## 
## #/components/schemas/AutomodMessageHoldEvent
class Event extends TwitchData:

	## The ID of the broadcaster specified in the request.
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	## The login of the broadcaster specified in the request.
	@export var broadcaster_user_login: String:
		set(val): 
			broadcaster_user_login = val
			track_data(&"broadcaster_user_login", val)
	
	## The user name of the broadcaster specified in the request.
	@export var broadcaster_user_name: String:
		set(val): 
			broadcaster_user_name = val
			track_data(&"broadcaster_user_name", val)
	
	## The message sender’s user ID.
	@export var user_id: String:
		set(val): 
			user_id = val
			track_data(&"user_id", val)
	
	## The message sender’s login name.
	@export var user_login: String:
		set(val): 
			user_login = val
			track_data(&"user_login", val)
	
	## The message sender’s display name.
	@export var user_name: String:
		set(val): 
			user_name = val
			track_data(&"user_name", val)
	
	## The ID of the message that was flagged by automod.
	@export var message_id: String:
		set(val): 
			message_id = val
			track_data(&"message_id", val)
	
	## The body of the message.
	@export var message: Message:
		set(val): 
			message = val
			track_data(&"message", val)
	
	## The category of the message.
	@export var category: String:
		set(val): 
			category = val
			track_data(&"category", val)
	
	## The level of severity. Measured between 1 to 4.
	@export var level: int:
		set(val): 
			level = val
			track_data(&"level", val)
	
	## The timestamp of when automod saved the message.
	@export var held_at: String:
		set(val): 
			held_at = val
			track_data(&"held_at", val)
	
	
	
	static func from_json(d: Dictionary) -> Event:
		var result: Event = Event.new()
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		if d.get("broadcaster_user_login", null) != null:
			result.broadcaster_user_login = d["broadcaster_user_login"]
		if d.get("broadcaster_user_name", null) != null:
			result.broadcaster_user_name = d["broadcaster_user_name"]
		if d.get("user_id", null) != null:
			result.user_id = d["user_id"]
		if d.get("user_login", null) != null:
			result.user_login = d["user_login"]
		if d.get("user_name", null) != null:
			result.user_name = d["user_name"]
		if d.get("message_id", null) != null:
			result.message_id = d["message_id"]
		if d.get("message", null) != null:
			result.message = Message.from_json(d["message"])
		if d.get("category", null) != null:
			result.category = d["category"]
		if d.get("level", null) != null:
			result.level = d["level"]
		if d.get("held_at", null) != null:
			result.held_at = d["held_at"]
		return result
	


## The body of the message.
## #/components/schemas/AutomodMessageHoldEvent/Message
class Message extends TwitchData:

	## The contents of the message caught by automod.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## Metadata surrounding the potential inappropriate fragments of the message.
	@export var fragments: Array[Fragments]:
		set(val): 
			fragments = val
			track_data(&"fragments", val)
	
	
	
	static func from_json(d: Dictionary) -> Message:
		var result: Message = Message.new()
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("fragments", null) != null:
			for value in d["fragments"]:
				result.fragments.append(Fragments.from_json(value))
		return result
	


## Metadata surrounding the potential inappropriate fragments of the message.
## #/components/schemas/AutomodMessageHoldEvent/Message/Fragments
class Fragments extends TwitchData:

	## Message text in a fragment.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## Optional. Metadata pertaining to the emote.
	@export var emote: Emote:
		set(val): 
			emote = val
			track_data(&"emote", val)
	
	## Optional. Metadata pertaining to the cheermote.
	@export var cheermote: Cheermote:
		set(val): 
			cheermote = val
			track_data(&"cheermote", val)
	
	
	
	static func from_json(d: Dictionary) -> Fragments:
		var result: Fragments = Fragments.new()
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("emote", null) != null:
			result.emote = Emote.from_json(d["emote"])
		if d.get("cheermote", null) != null:
			result.cheermote = Cheermote.from_json(d["cheermote"])
		return result
	


## Optional. Metadata pertaining to the emote.
## #/components/schemas/AutomodMessageHoldEvent/Message/Fragments/Emote
class Emote extends TwitchData:

	## An ID that uniquely identifies this emote.
	@export var id: String:
		set(val): 
			id = val
			track_data(&"id", val)
	
	## An ID that identifies the emote set that the emote belongs to.
	@export var emote_set_id: String:
		set(val): 
			emote_set_id = val
			track_data(&"emote_set_id", val)
	
	
	
	static func from_json(d: Dictionary) -> Emote:
		var result: Emote = Emote.new()
		if d.get("id", null) != null:
			result.id = d["id"]
		if d.get("emote_set_id", null) != null:
			result.emote_set_id = d["emote_set_id"]
		return result
	


## Optional. Metadata pertaining to the cheermote.
## #/components/schemas/AutomodMessageHoldEvent/Message/Fragments/Cheermote
class Cheermote extends TwitchData:

	## The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is “Cheer” and you want to cheer 100 Bits, the full Cheermote string is Cheer100. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.
	@export var prefix: String:
		set(val): 
			prefix = val
			track_data(&"prefix", val)
	
	## The amount of Bits cheered.
	@export var bits: int:
		set(val): 
			bits = val
			track_data(&"bits", val)
	
	## The tier level of the cheermote.
	@export var tier: int:
		set(val): 
			tier = val
			track_data(&"tier", val)
	
	
	
	static func from_json(d: Dictionary) -> Cheermote:
		var result: Cheermote = Cheermote.new()
		if d.get("prefix", null) != null:
			result.prefix = d["prefix"]
		if d.get("bits", null) != null:
			result.bits = d["bits"]
		if d.get("tier", null) != null:
			result.tier = d["tier"]
		return result
	


## 
## #/components/schemas/AutomodMessageHoldEventV2
class EventV2 extends TwitchData:

	## The ID of the broadcaster specified in the request.
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	## The login of the broadcaster specified in the request.
	@export var broadcaster_user_login: String:
		set(val): 
			broadcaster_user_login = val
			track_data(&"broadcaster_user_login", val)
	
	## The user name of the broadcaster specified in the request.
	@export var broadcaster_user_name: String:
		set(val): 
			broadcaster_user_name = val
			track_data(&"broadcaster_user_name", val)
	
	## The message sender’s user ID.
	@export var user_id: String:
		set(val): 
			user_id = val
			track_data(&"user_id", val)
	
	## The message sender’s login name.
	@export var user_login: String:
		set(val): 
			user_login = val
			track_data(&"user_login", val)
	
	## The message sender’s display name.
	@export var user_name: String:
		set(val): 
			user_name = val
			track_data(&"user_name", val)
	
	## The ID of the held message.
	@export var message_id: String:
		set(val): 
			message_id = val
			track_data(&"message_id", val)
	
	## The body of the message.
	@export var message: MessageV2:
		set(val): 
			message = val
			track_data(&"message", val)
	
	## The timestamp of when automod saved the message.
	@export var held_at: String:
		set(val): 
			held_at = val
			track_data(&"held_at", val)
	
	## Possible values are: automodblocked_term
	@export var reason: String:
		set(val): 
			reason = val
			track_data(&"reason", val)
	
	## Optional. If the message was caught by automod, this will be populated.
	@export var automod: AutomodV2:
		set(val): 
			automod = val
			track_data(&"automod", val)
	
	## Optional. If the message was caught due to a blocked term, this will be populated.
	@export var blocked_term: BlockedTermV2:
		set(val): 
			blocked_term = val
			track_data(&"blocked_term", val)
	
	
	
	static func from_json(d: Dictionary) -> EventV2:
		var result: EventV2 = EventV2.new()
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		if d.get("broadcaster_user_login", null) != null:
			result.broadcaster_user_login = d["broadcaster_user_login"]
		if d.get("broadcaster_user_name", null) != null:
			result.broadcaster_user_name = d["broadcaster_user_name"]
		if d.get("user_id", null) != null:
			result.user_id = d["user_id"]
		if d.get("user_login", null) != null:
			result.user_login = d["user_login"]
		if d.get("user_name", null) != null:
			result.user_name = d["user_name"]
		if d.get("message_id", null) != null:
			result.message_id = d["message_id"]
		if d.get("message", null) != null:
			result.message = MessageV2.from_json(d["message"])
		if d.get("held_at", null) != null:
			result.held_at = d["held_at"]
		if d.get("reason", null) != null:
			result.reason = d["reason"]
		if d.get("automod", null) != null:
			result.automod = AutomodV2.from_json(d["automod"])
		if d.get("blocked_term", null) != null:
			result.blocked_term = BlockedTermV2.from_json(d["blocked_term"])
		return result
	


## The body of the message.
## #/components/schemas/AutomodMessageHoldEventV2/Message
class MessageV2 extends TwitchData:

	## The contents of the message caught by automod.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## Metadata surrounding the potential inappropriate fragments of the message.
	@export var fragments: Array[FragmentsV2]:
		set(val): 
			fragments = val
			track_data(&"fragments", val)
	
	
	
	static func from_json(d: Dictionary) -> MessageV2:
		var result: MessageV2 = MessageV2.new()
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("fragments", null) != null:
			for value in d["fragments"]:
				result.fragments.append(FragmentsV2.from_json(value))
		return result
	


## Metadata surrounding the potential inappropriate fragments of the message.
## #/components/schemas/AutomodMessageHoldEventV2/Message/Fragments
class FragmentsV2 extends TwitchData:

	## One of three options:textemotecheermote
	@export var type: String:
		set(val): 
			type = val
			track_data(&"type", val)
	
	## Message text in a fragment.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## Optional. Metadata pertaining to the emote.
	@export var emote: EmoteV2:
		set(val): 
			emote = val
			track_data(&"emote", val)
	
	## Optional. Metadata pertaining to the cheermote.
	@export var cheermote: CheermoteV2:
		set(val): 
			cheermote = val
			track_data(&"cheermote", val)
	
	
	
	static func from_json(d: Dictionary) -> FragmentsV2:
		var result: FragmentsV2 = FragmentsV2.new()
		if d.get("type", null) != null:
			result.type = d["type"]
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("emote", null) != null:
			result.emote = EmoteV2.from_json(d["emote"])
		if d.get("cheermote", null) != null:
			result.cheermote = CheermoteV2.from_json(d["cheermote"])
		return result
	


## Optional. Metadata pertaining to the emote.
## #/components/schemas/AutomodMessageHoldEventV2/Message/Fragments/Emote
class EmoteV2 extends TwitchData:

	## An ID that uniquely identifies this emote.
	@export var id: String:
		set(val): 
			id = val
			track_data(&"id", val)
	
	## An ID that identifies the emote set that the emote belongs to.
	@export var emote_set_id: String:
		set(val): 
			emote_set_id = val
			track_data(&"emote_set_id", val)
	
	
	
	static func from_json(d: Dictionary) -> EmoteV2:
		var result: EmoteV2 = EmoteV2.new()
		if d.get("id", null) != null:
			result.id = d["id"]
		if d.get("emote_set_id", null) != null:
			result.emote_set_id = d["emote_set_id"]
		return result
	


## Optional. Metadata pertaining to the cheermote.
## #/components/schemas/AutomodMessageHoldEventV2/Message/Fragments/Cheermote
class CheermoteV2 extends TwitchData:

	## The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is “Cheer” and you want to cheer 100 Bits, the full Cheermote string is Cheer100. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.
	@export var prefix: String:
		set(val): 
			prefix = val
			track_data(&"prefix", val)
	
	## The amount of Bits cheered.
	@export var bits: int:
		set(val): 
			bits = val
			track_data(&"bits", val)
	
	## The tier level of the cheermote.
	@export var tier: int:
		set(val): 
			tier = val
			track_data(&"tier", val)
	
	
	
	static func from_json(d: Dictionary) -> CheermoteV2:
		var result: CheermoteV2 = CheermoteV2.new()
		if d.get("prefix", null) != null:
			result.prefix = d["prefix"]
		if d.get("bits", null) != null:
			result.bits = d["bits"]
		if d.get("tier", null) != null:
			result.tier = d["tier"]
		return result
	


## Optional. If the message was caught by automod, this will be populated.
## #/components/schemas/AutomodMessageHoldEventV2/Automod
class AutomodV2 extends TwitchData:

	## The category of the caught message.
	@export var category: String:
		set(val): 
			category = val
			track_data(&"category", val)
	
	## The level of severity (1-4).
	@export var level: int:
		set(val): 
			level = val
			track_data(&"level", val)
	
	## The bounds of the text that caused the message to be caught.
	@export var boundaries: Array[BoundariesV2]:
		set(val): 
			boundaries = val
			track_data(&"boundaries", val)
	
	
	
	static func from_json(d: Dictionary) -> AutomodV2:
		var result: AutomodV2 = AutomodV2.new()
		if d.get("category", null) != null:
			result.category = d["category"]
		if d.get("level", null) != null:
			result.level = d["level"]
		if d.get("boundaries", null) != null:
			for value in d["boundaries"]:
				result.boundaries.append(BoundariesV2.from_json(value))
		return result
	


## The bounds of the text that caused the message to be caught.
## #/components/schemas/AutomodMessageHoldEventV2/Automod/Boundaries
class BoundariesV2 extends TwitchData:

	## Index in the message for the start of the problem (0 indexed, inclusive).
	@export var start_pos: int:
		set(val): 
			start_pos = val
			track_data(&"start_pos", val)
	
	## Index in the message for the end of the problem (0 indexed, inclusive).
	@export var end_pos: int:
		set(val): 
			end_pos = val
			track_data(&"end_pos", val)
	
	
	
	static func from_json(d: Dictionary) -> BoundariesV2:
		var result: BoundariesV2 = BoundariesV2.new()
		if d.get("start_pos", null) != null:
			result.start_pos = d["start_pos"]
		if d.get("end_pos", null) != null:
			result.end_pos = d["end_pos"]
		return result
	


## Optional. If the message was caught due to a blocked term, this will be populated.
## #/components/schemas/AutomodMessageHoldEventV2/BlockedTerm
class BlockedTermV2 extends TwitchData:

	## The list of blocked terms found in the message.
	@export var terms_found: Array[TermsFoundV2]:
		set(val): 
			terms_found = val
			track_data(&"terms_found", val)
	
	
	
	static func from_json(d: Dictionary) -> BlockedTermV2:
		var result: BlockedTermV2 = BlockedTermV2.new()
		if d.get("terms_found", null) != null:
			for value in d["terms_found"]:
				result.terms_found.append(TermsFoundV2.from_json(value))
		return result
	


## The list of blocked terms found in the message.
## #/components/schemas/AutomodMessageHoldEventV2/BlockedTerm/TermsFound
class TermsFoundV2 extends TwitchData:

	## The id of the blocked term found.
	@export var term_id: String:
		set(val): 
			term_id = val
			track_data(&"term_id", val)
	
	## The bounds of the text that caused the message to be caught.
	@export var boundary: BoundaryV2:
		set(val): 
			boundary = val
			track_data(&"boundary", val)
	
	## The id of the broadcaster that owns the blocked term.
	@export var owner_broadcaster_user_id: String:
		set(val): 
			owner_broadcaster_user_id = val
			track_data(&"owner_broadcaster_user_id", val)
	
	## The login of the broadcaster that owns the blocked term.
	@export var owner_broadcaster_user_login: String:
		set(val): 
			owner_broadcaster_user_login = val
			track_data(&"owner_broadcaster_user_login", val)
	
	## The username of the broadcaster that owns the blocked term.
	@export var owner_broadcaster_user_name: String:
		set(val): 
			owner_broadcaster_user_name = val
			track_data(&"owner_broadcaster_user_name", val)
	
	
	
	static func from_json(d: Dictionary) -> TermsFoundV2:
		var result: TermsFoundV2 = TermsFoundV2.new()
		if d.get("term_id", null) != null:
			result.term_id = d["term_id"]
		if d.get("boundary", null) != null:
			result.boundary = BoundaryV2.from_json(d["boundary"])
		if d.get("owner_broadcaster_user_id", null) != null:
			result.owner_broadcaster_user_id = d["owner_broadcaster_user_id"]
		if d.get("owner_broadcaster_user_login", null) != null:
			result.owner_broadcaster_user_login = d["owner_broadcaster_user_login"]
		if d.get("owner_broadcaster_user_name", null) != null:
			result.owner_broadcaster_user_name = d["owner_broadcaster_user_name"]
		return result
	


## The bounds of the text that caused the message to be caught.
## #/components/schemas/AutomodMessageHoldEventV2/BlockedTerm/TermsFound/Boundary
class BoundaryV2 extends TwitchData:

	## Index in the message for the start of the problem (0 indexed, inclusive).
	@export var start_pos: int:
		set(val): 
			start_pos = val
			track_data(&"start_pos", val)
	
	## Index in the message for the end of the problem (0 indexed, inclusive).
	@export var end_pos: int:
		set(val): 
			end_pos = val
			track_data(&"end_pos", val)
	
	
	
	static func from_json(d: Dictionary) -> BoundaryV2:
		var result: BoundaryV2 = BoundaryV2.new()
		if d.get("start_pos", null) != null:
			result.start_pos = d["start_pos"]
		if d.get("end_pos", null) != null:
			result.end_pos = d["end_pos"]
		return result
	