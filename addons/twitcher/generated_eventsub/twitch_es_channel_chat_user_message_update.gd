@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchESChannelChatUserMessageUpdate
	


## 
## #/components/schemas/ChannelChatUserMessageUpdateCondition
class Condition extends TwitchData:

	## User ID of the channel to receive chat message events for.
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	## The user ID to read chat as.
	@export var user_id: String:
		set(val): 
			user_id = val
			track_data(&"user_id", val)
	
	
	
	static func from_json(d: Dictionary) -> Condition:
		var result: Condition = Condition.new()
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		if d.get("user_id", null) != null:
			result.user_id = d["user_id"]
		return result
	


## 
## #/components/schemas/ChannelChatUserMessageUpdateEvent
class Event extends TwitchData:

	## The ID of the broadcaster specified in the request.
	@export var broadcaster_user_id: String:
		set(val): 
			broadcaster_user_id = val
			track_data(&"broadcaster_user_id", val)
	
	## The login of the broadcaster specified in the request.
	@export var broadcaster_user_login: String:
		set(val): 
			broadcaster_user_login = val
			track_data(&"broadcaster_user_login", val)
	
	## The user name of the broadcaster specified in the request.
	@export var broadcaster_user_name: String:
		set(val): 
			broadcaster_user_name = val
			track_data(&"broadcaster_user_name", val)
	
	## The User ID of the message sender.
	@export var user_id: String:
		set(val): 
			user_id = val
			track_data(&"user_id", val)
	
	## The message sender’s login.
	@export var user_login: String:
		set(val): 
			user_login = val
			track_data(&"user_login", val)
	
	## The message sender’s user name.
	@export var user_name: String:
		set(val): 
			user_name = val
			track_data(&"user_name", val)
	
	## The message’s status. Possible values are:approveddeniedinvalid
	@export var status: String:
		set(val): 
			status = val
			track_data(&"status", val)
	
	## The ID of the message that was flagged by automod.
	@export var message_id: String:
		set(val): 
			message_id = val
			track_data(&"message_id", val)
	
	## The body of the message.
	@export var message: Message:
		set(val): 
			message = val
			track_data(&"message", val)
	
	
	
	static func from_json(d: Dictionary) -> Event:
		var result: Event = Event.new()
		if d.get("broadcaster_user_id", null) != null:
			result.broadcaster_user_id = d["broadcaster_user_id"]
		if d.get("broadcaster_user_login", null) != null:
			result.broadcaster_user_login = d["broadcaster_user_login"]
		if d.get("broadcaster_user_name", null) != null:
			result.broadcaster_user_name = d["broadcaster_user_name"]
		if d.get("user_id", null) != null:
			result.user_id = d["user_id"]
		if d.get("user_login", null) != null:
			result.user_login = d["user_login"]
		if d.get("user_name", null) != null:
			result.user_name = d["user_name"]
		if d.get("status", null) != null:
			result.status = d["status"]
		if d.get("message_id", null) != null:
			result.message_id = d["message_id"]
		if d.get("message", null) != null:
			result.message = Message.from_json(d["message"])
		return result
	


## The body of the message.
## #/components/schemas/ChannelChatUserMessageUpdateEvent/Message
class Message extends TwitchData:

	## The contents of the message caught by automod.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## Ordered list of chat message fragments.
	@export var fragments: Array[Fragments]:
		set(val): 
			fragments = val
			track_data(&"fragments", val)
	
	
	
	static func from_json(d: Dictionary) -> Message:
		var result: Message = Message.new()
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("fragments", null) != null:
			for value in d["fragments"]:
				result.fragments.append(Fragments.from_json(value))
		return result
	


## Ordered list of chat message fragments.
## #/components/schemas/ChannelChatUserMessageUpdateEvent/Message/Fragments
class Fragments extends TwitchData:

	## Message text in a fragment.
	@export var text: String:
		set(val): 
			text = val
			track_data(&"text", val)
	
	## Optional. Metadata pertaining to the emote.
	@export var emote: Emote:
		set(val): 
			emote = val
			track_data(&"emote", val)
	
	## Optional. Metadata pertaining to the cheermote.
	@export var cheermote: Cheermote:
		set(val): 
			cheermote = val
			track_data(&"cheermote", val)
	
	
	
	static func from_json(d: Dictionary) -> Fragments:
		var result: Fragments = Fragments.new()
		if d.get("text", null) != null:
			result.text = d["text"]
		if d.get("emote", null) != null:
			result.emote = Emote.from_json(d["emote"])
		if d.get("cheermote", null) != null:
			result.cheermote = Cheermote.from_json(d["cheermote"])
		return result
	


## Optional. Metadata pertaining to the emote.
## #/components/schemas/ChannelChatUserMessageUpdateEvent/Message/Fragments/Emote
class Emote extends TwitchData:

	## An ID that uniquely identifies this emote.
	@export var id: String:
		set(val): 
			id = val
			track_data(&"id", val)
	
	## An ID that identifies the emote set that the emote belongs to.
	@export var emote_set_id: String:
		set(val): 
			emote_set_id = val
			track_data(&"emote_set_id", val)
	
	
	
	static func from_json(d: Dictionary) -> Emote:
		var result: Emote = Emote.new()
		if d.get("id", null) != null:
			result.id = d["id"]
		if d.get("emote_set_id", null) != null:
			result.emote_set_id = d["emote_set_id"]
		return result
	


## Optional. Metadata pertaining to the cheermote.
## #/components/schemas/ChannelChatUserMessageUpdateEvent/Message/Fragments/Cheermote
class Cheermote extends TwitchData:

	## The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is “Cheer” and you want to cheer 100 Bits, the full Cheermote string is Cheer100. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.
	@export var prefix: String:
		set(val): 
			prefix = val
			track_data(&"prefix", val)
	
	## The amount of Bits cheered.
	@export var bits: int:
		set(val): 
			bits = val
			track_data(&"bits", val)
	
	## The tier level of the cheermote.
	@export var tier: int:
		set(val): 
			tier = val
			track_data(&"tier", val)
	
	
	
	static func from_json(d: Dictionary) -> Cheermote:
		var result: Cheermote = Cheermote.new()
		if d.get("prefix", null) != null:
			result.prefix = d["prefix"]
		if d.get("bits", null) != null:
			result.bits = d["bits"]
		if d.get("tier", null) != null:
			result.tier = d["tier"]
		return result
	